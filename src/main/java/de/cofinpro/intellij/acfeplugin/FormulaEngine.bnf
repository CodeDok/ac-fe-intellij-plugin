{
    parserClass="de.cofinpro.intellij.acfeplugin.parser.FormulaEngineParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="FormulaEngine"
    psiImplClassSuffix="Impl"
    psiPackage="de.cofinpro.intellij.acfeplugin.psi"
    psiImplPackage="de.cofinpro.intellij.acfeplugin.psi.impl"

    elementTypeHolderClass="de.cofinpro.intellij.acfeplugin.psi.FormulaEngineElementTypes"
    elementTypeClass="de.cofinpro.intellij.acfeplugin.psi.FormulaEngineElementType"
    tokenTypeClass="de.cofinpro.intellij.acfeplugin.psi.FormulaEngineTokenType"

    tokens = [
            LEFT_PARENTHESIS = '('
            RIGHT_PARENTHESIS = ')'
            LEFT_CURLY_BRACE = '{'
            RIGHT_CURLY_BRACE = '}'
            LEFT_BRACKET = '['
            RIGHT_BRACKET = ']'

            OPERATOR_ASSIGNMENT = '='
            OPERATOR_AND = '&&'
            OPERATOR_DECREMENT = '--'
            OPERATOR_DIVIDE = '/'
            OPERATOR_EQUAL = '=='
            OPERATOR_GREATERTHAN = '>'
            OPERATOR_GREATERTHANEQUAL = '>='
            OPERATOR_INCREMENT = '++'
            OPERATOR_LESSTHAN = '<'
            OPERATOR_LESSTHANEQUAL = '<='
            OPERATOR_MINUS = '-'
            OPERATOR_MODULO = '%'
            OPERATOR_NEGATION = '!'
            OPERATOR_NOTEQUAL = '!='
            OPERATOR_OR = '||'
            OPERATOR_MULTIPLY = '*'
            OPERATOR_PLUS = '+'

            KEYWORD_AND = 'and'
            KEYWORD_BREAK = 'break'
            KEYWORD_CASE = 'case'
            KEYWORD_DEFAULT = 'default'
            KEYWORD_DO = 'do'
            KEYWORD_ELSE = 'else'
            KEYWORD_FOR = 'for'
            KEYWORD_FUNCTION = 'function'
            KEYWORD_IF = 'if'
            KEYWORD_OR = 'or'
            KEYWORD_RETURN = 'return'
            KEYWORD_SEQ = 'seq'
            KEYWORD_SWITCH = 'switch'
            KEYWORD_WHILE = 'while'

            TYPE_INTEGER = 'integer'
            TYPE_FLOAT = 'float'
            TYPE_DATE = 'date'
            TYPE_STRING = 'string'
            TYPE_LIST = 'list'
            TYPE_DICT = 'dict'
            TYPE_ANY = 'any'

            VISIBILITY_GLOBAL = 'global'
            VISIBILITY_LOCAL = 'local'

            BUILT_IN_VAR_NA = '$NA'
            BUILT_IN_VAR_TODAY = '$TODAY'

            BUILT_IN_FUNC_ATTRIBUTE = 'attribute'
            BUILT_IN_FUNC_DATE = 'date'
            BUILT_IN_FUNC_DATETIME = 'datetime'
            BUILT_IN_FUNC_DAYDIFF = 'daydiff'
            BUILT_IN_FUNC_DAYPLUS = 'dayplus'
            BUILT_IN_FUNC_ELT = 'elt'
            BUILT_IN_FUNC_FIRST = 'first'
            BUILT_IN_FUNC_FLOAT = 'float'
            BUILT_IN_FUNC_HASH_GET = 'hash_get'
            BUILT_IN_FUNC_HASH_ISKEY = 'hash_iskey'
            BUILT_IN_FUNC_HASH_KEYS = 'hash_keys'
            BUILT_IN_FUNC_HASH_PUT = 'hash_put'
            BUILT_IN_FUNC_INTEGER = 'integer'
            BUILT_IN_FUNC_IS_LIST = 'is_list'
            BUILT_IN_FUNC_IS_NA = 'is_na'
            BUILT_IN_FUNC_IS_STRING = 'is_string'
            BUILT_IN_FUNC_KERNEL = 'kernel'
            BUILT_IN_FUNC_LEN = 'len'
            BUILT_IN_FUNC_LOAD = 'load'
            BUILT_IN_FUNC_REMOVE = 'remove'
            BUILT_IN_FUNC_STATUS = 'status'
            BUILT_IN_FUNC_STR = 'str'
            BUILT_IN_FUNC_STRING = 'string'
            BUILT_IN_FUNC_OUT = 'out'

            DOUBLE_QUOTED_STRING_LITERAL = 'double quoted string literal'
            SINGLE_QUOTED_STRING_LITERAL = 'single quoted string literal'
            DOUBLE_QUOTED_STRING="regexp:\"([^\\\"\r\n]|\\[^\r\n])*\"?"
            SINGLE_QUOTED_STRING="regexp:'([^\\\'\r\n]|\\[^\r\n])*'?"

            COMMA = ','
            COLON = ':'
            SEMICOLON = ';'
            MINUS = '-'
            QUESIONMARK = '?'

            IDENTIFIER = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
            LINE_COMMENT='regexp://.*'
            BLOCK_COMMENT='regexp:/\*([^*]|\*+[^*/])*(\*+/)?'
            WHITE_SPACE = 'regexp:\s+'

            NUMBER_INTEGER = 'regexp:[0-9]+'
    ]

      extends(".*Expression")=Expression
}

feFile ::= TopLevelItem*

TopLevelItem ::= FunctionDefinition | ControlStructure | Statement

FunctionDefinition ::= KEYWORD_FUNCTION IDENTIFIER LEFT_PARENTHESIS FunctionParameters? RIGHT_PARENTHESIS LEFT_CURLY_BRACE FunctionBody RIGHT_CURLY_BRACE
FunctionParameters ::= FunctionParameter (COMMA FunctionParameter)*
FunctionParameter ::= Type? IDENTIFIER

FunctionArguments ::= FunctionArgument (COMMA FunctionArgument)*
FunctionArgument ::= Expression

// Control Structures
ControlStructure ::= (ControlStructureKeyword LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS LEFT_CURLY_BRACE ControlStructureBody RIGHT_CURLY_BRACE) | For | If | Switch | DoWhile
ControlStructureKeyword ::= KEYWORD_FOR | KEYWORD_WHILE
ControlStructureBody ::= (ControlStructure | Statement)*

Switch ::= KEYWORD_SWITCH LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS LEFT_CURLY_BRACE (KEYWORD_CASE Constant COLON (ControlStructureBody (KEYWORD_BREAK SEMICOLON)?))* (KEYWORD_DEFAULT Constant COLON (ControlStructureBody (KEYWORD_BREAK SEMICOLON)?))?
DoWhile ::= KEYWORD_DO LEFT_CURLY_BRACE ControlStructureBody RIGHT_CURLY_BRACE KEYWORD_WHILE LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS SEMICOLON

// Expressions
Expression ::= NegatedExpression
    | CombinationExpression
    | ComparisonExpression
    | CalculationExpression
    | ShortIfExpression
    | LeafExpression
    | ParenthesisExpression
NegatedExpression ::= OPERATOR_NEGATION Expression
CombinationExpression ::= Expression CombinationOperator Expression
ComparisonExpression ::= Expression ComparisonOperator Expression
CalculationExpression ::= Expression CalculationOperator Expression
ShortIfExpression ::= Expression QUESIONMARK Expression COLON Expression
LeafExpression ::= FunctionInvocation | Constant  | ArrayAccess | IDENTIFIER PostfixOperator?
ParenthesisExpression ::= LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS

CombinationOperator ::= OPERATOR_AND | OPERATOR_OR | KEYWORD_AND | KEYWORD_OR
ComparisonOperator ::= OPERATOR_EQUAL | OPERATOR_NOTEQUAL | OPERATOR_GREATERTHANEQUAL | OPERATOR_GREATERTHAN | OPERATOR_LESSTHANEQUAL | OPERATOR_LESSTHAN
CalculationOperator ::= OPERATOR_MODULO | OPERATOR_PLUS | MINUS | OPERATOR_MULTIPLY | OPERATOR_DIVIDE
PostfixOperator ::= OPERATOR_INCREMENT | OPERATOR_DECREMENT

StringLiteral ::= SingleStringLiteral (OPERATOR_PLUS Expression)* | SingleStringLiteral (OPERATOR_PLUS SingleStringLiteral)*
SingleStringLiteral ::= SINGLE_QUOTED_STRING | DOUBLE_QUOTED_STRING
ListLiteral ::= LEFT_BRACKET ListContents RIGHT_BRACKET
ListContents ::= (Expression (COMMA Expression)*)?

FunctionInvocation ::= (BuiltInFunctionName | CustomFunctionName) LEFT_PARENTHESIS FunctionArguments? RIGHT_PARENTHESIS
CustomFunctionName ::= IDENTIFIER

BuiltInFunctionName ::= BUILT_IN_FUNC_ATTRIBUTE | BUILT_IN_FUNC_STATUS
    | BUILT_IN_FUNC_DATE | BUILT_IN_FUNC_DATETIME | BUILT_IN_FUNC_STR | BUILT_IN_FUNC_FLOAT | BUILT_IN_FUNC_INTEGER
    | BUILT_IN_FUNC_DAYDIFF | BUILT_IN_FUNC_DAYPLUS
    | BUILT_IN_FUNC_ELT
    | BUILT_IN_FUNC_FIRST
    | BUILT_IN_FUNC_HASH_GET | BUILT_IN_FUNC_HASH_PUT | BUILT_IN_FUNC_HASH_ISKEY | BUILT_IN_FUNC_HASH_KEYS
    | BUILT_IN_FUNC_IS_LIST | BUILT_IN_FUNC_IS_NA | BUILT_IN_FUNC_IS_STRING
    | BUILT_IN_FUNC_KERNEL
    | BUILT_IN_FUNC_LEN
    | BUILT_IN_FUNC_LOAD
    | BUILT_IN_FUNC_OUT
    | BUILT_IN_FUNC_REMOVE
FunctionBody ::= FunctionBodyStatement*
Statement ::= (FunctionInvocation | Assignment | Declaration | ReturnStatement) ';'
StatementWithoutEol ::= FunctionInvocation | Assignment | Declaration // This is a hack and has a better solution for sure..
FunctionBodyStatement ::= ControlStructure | ((FunctionInvocation | Assignment | Declaration | ReturnStatement) SEMICOLON)

SeqForParenthesis ::= LEFT_PARENTHESIS Assignment SEMICOLON Expression SEMICOLON Assignment RIGHT_PARENTHESIS
Seq ::= KEYWORD_SEQ SeqForParenthesis StatementWithoutEol
For ::= KEYWORD_FOR SeqForParenthesis LEFT_CURLY_BRACE ControlStructureBody RIGHT_CURLY_BRACE
If ::= KEYWORD_IF LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS LEFT_CURLY_BRACE ControlStructureBody RIGHT_CURLY_BRACE (KEYWORD_ELSE KEYWORD_IF LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS LEFT_CURLY_BRACE ControlStructureBody RIGHT_CURLY_BRACE)* (KEYWORD_ELSE LEFT_CURLY_BRACE ControlStructureBody RIGHT_CURLY_BRACE)?

Declaration ::= Visibility? Type? IDENTIFIER
Assignment ::= (Declaration OPERATOR_ASSIGNMENT (Seq | Expression)) | IDENTIFIER PostfixOperator

ArrayAccess ::= IDENTIFIER (LEFT_BRACKET (NUMBER_INTEGER | IDENTIFIER) RIGHT_BRACKET)+

ReturnStatement ::= KEYWORD_RETURN Expression

Visibility ::= VISIBILITY_GLOBAL | VISIBILITY_LOCAL
Type ::= TYPE_INTEGER | TYPE_FLOAT | TYPE_DATE | TYPE_STRING | TYPE_LIST | TYPE_DICT | TYPE_ANY

Constant ::= BuiltInVariableName | MINUS? NUMBER_INTEGER | StringLiteral | ListLiteral
BuiltInVariableName ::= BUILT_IN_VAR_NA | BUILT_IN_VAR_TODAY